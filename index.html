estaba pensando en eque hacer en el taller de matematicas con mis alumnos empezamos haciendo sudokus, piramides, calcudokus y ya se estan empezando a aburrir que sugerencias tienes

18:35

Identific√≥ necesidad de actividades matem√°ticas innovadoras y interactivas.



¬°Buena pregunta! Despu√©s de los cl√°sicos de l√≥gica num√©rica, hay un mundo de opciones para mantener el engagement. Aqu√≠ van algunas ideas organizadas por tipo:

Puzzles de l√≥gica no num√©ricos

Nonogramas (Picross): revelan una imagen oculta siguiendo pistas num√©ricas. Muy satisfactorios y con dificultad escalable.
Puzzles de Einstein/Zebra: "El noruego vive en la primera casa, el que fuma Blend vive al lado del que tiene gatos..." Trabajan deducci√≥n pura.
Laberintos l√≥gicos con reglas (solo puedes pisar n√∫meros pares, o siguiendo una secuencia).
Matem√°ticas con componente manipulativo o visual

Tangram matem√°tico: resolver problemas de √°reas, fracciones o √°ngulos construyendo figuras.
Origami matem√°tico: desde el teorema de Pit√°goras doblando papel hasta fractales como el tetraedro de Sierpinski.
Torres de Han√≥i: introducci√≥n a recursividad y potencias de 2.
Juegos estrat√©gicos con matem√°ticas subyacentes

Nim y variantes: teor√≠a de juegos accesible, pueden descubrir la estrategia ganadora.
Set (el juego de cartas): combinatoria y reconocimiento de patrones a toda velocidad.
Rummikub matem√°tico: operaciones para formar ecuaciones.
Retos colaborativos o competitivos

Escape rooms matem√°ticos: puedes dise√±ar uno con candados de combinaci√≥n donde cada puzzle da un n√∫mero.
Fermi problems: "¬øCu√°ntas pelotas de tenis caben en esta aula?" Estimaci√≥n y razonamiento.
Concursos tipo Countdown: con n√∫meros dados, llegar a un objetivo usando operaciones.
Con un toque tecnol√≥gico (dado tu perfil STEAM)

Pixel art en hoja cuadriculada siguiendo coordenadas o instrucciones codificadas.
Programaci√≥n desenchufada: algoritmos de ordenaci√≥n con cartas, debugging de "programas" en papel.
¬øQu√© nivel son los alumnos del taller y cu√°nto tiempo dura cada sesi√≥n? As√≠ te afino mejor las sugerencias.

Dame una sugerencia especifica y desarrollada para juzgar

18:36

Seleccion√≥ y desarroll√≥ una propuesta educativa con criterios espec√≠ficos.




Nonogramas (Picross): L√≥gica que revela arte
¬øQu√© son?
Puzzles en cuadr√≠cula donde las pistas num√©ricas en filas y columnas indican qu√© celdas colorear. Al resolverlo, aparece una imagen oculta. Esa recompensa visual es lo que los hace tan adictivos.

Reglas b√°sicas
Los n√∫meros indican grupos consecutivos de celdas coloreadas en esa fila/columna.
Entre grupos debe haber al menos una celda vac√≠a.
El orden de los n√∫meros corresponde al orden de los grupos (izquierda‚Üíderecha, arriba‚Üíabajo).
Ejemplo: en una fila de 10 celdas, la pista 3 4 significa:

Un bloque de 3 celdas, luego al menos 1 vac√≠a, luego un bloque de 4 celdas.

Ejemplo resuelto paso a paso (5√ó5)
        1 
    1 3 1 3 1
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
 5 ‚îÇ‚ñ† ‚ñ† ‚ñ† ‚ñ† ‚ñ†‚îÇ  ‚Üê La pista es 5, y hay 5 celdas: todas coloreadas
 1 ‚îÇ¬∑ ¬∑ ‚ñ† ¬∑ ¬∑‚îÇ  
 3 ‚îÇ¬∑ ‚ñ† ‚ñ† ‚ñ† ¬∑‚îÇ  
 1 ‚îÇ¬∑ ¬∑ ‚ñ† ¬∑ ¬∑‚îÇ  
 1 ‚îÇ¬∑ ¬∑ ‚ñ† ¬∑ ¬∑‚îÇ  
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
Proceso de resoluci√≥n:

Fila con pista 5: Solo cabe de una forma ‚Üí colorear todo.
Columna central (pista 3): Ya tiene 3 de la fila anterior, verificamos que encaja con las otras filas.
T√©cnica del solapamiento: Si la pista es 3 en 5 celdas, el bloque podr√≠a empezar en posici√≥n 1, 2 o 3. La celda central (posici√≥n 3) est√° en todas las posibilidades ‚Üí se puede colorear con certeza.
Progresi√≥n de dificultad sugerida
Sesi√≥n	Tama√±o	Caracter√≠stica
1	5√ó5	Una sola soluci√≥n obvia, pistas grandes
2	5√ó5	Requiere solapamiento b√°sico
3	10√ó10	Im√°genes reconocibles (coraz√≥n, estrella)
4	10√ó10	M√∫ltiples grupos por l√≠nea
5+	15√ó15	Dise√±o propio para un compa√±ero
Actividad estrella: "Dise√±a tu propio nonograma"
Aqu√≠ es donde se dispara el aprendizaje:

El alumno dibuja una figura simple en cuadr√≠cula (su inicial, un emoji, un s√≠mbolo).
Cuenta los grupos de cada fila y columna para generar las pistas.
Prueba crucial: debe darlo a otro compa√±ero para verificar que tiene soluci√≥n √∫nica.
Si el compa√±ero no puede resolverlo o encuentra ambig√ºedad, hay que redise√±ar.
Esto trabaja reversibilidad del pensamiento y obliga a entender profundamente la mec√°nica.

Conexiones curriculares
Coordenadas cartesianas: localizaci√≥n de celdas
Combinatoria: ¬øde cu√°ntas formas puede colocarse un bloque de 3 en 7 celdas?
Pensamiento computacional: es esencialmente un problema de satisfacci√≥n de restricciones
¬øTe parece viable? Si quieres, te preparo una ficha con varios nonogramas graduados listos para imprimir.

no me enteroi del todo con el ejempplo dame un par de ellos que yo vea

18:39

Ide√≥ ejemplos visuales claros para explicar nonogramas mejor.


Tienes raz√≥n, mejor verlo que explicarlo. Te preparo un par de ejemplos visuales bien claros.


2 pasos

Presented file

Prepar√≥ ejemplos adicionales para clarificar el concepto.

Ah√≠ tienes tres ejemplos visuales:

La cruz - El m√°s f√°cil. Pistas simples de un solo n√∫mero donde ves claramente c√≥mo el "5" significa "colorea las 5 celdas".
El coraz√≥n - Introduce la pista con dos n√∫meros (2 2), que significa "un grupo de 2, hueco, otro grupo de 2".
Uno para resolver t√∫ - Con la soluci√≥n oculta para que compruebes si lo pillas.
La clave est√° en el primer ejemplo: cuando la pista coincide con el tama√±o de la fila, no hay duda posible. A partir de ah√≠ vas cruzando informaci√≥n entre filas y columnas.

¬øTe queda m√°s claro ahora? Si lo ves viable para el taller, te preparo una ficha imprimible con puzzles graduados por dificultad.

Nonogramas ejemplos
C√≥digo ¬∑ HTML 
1769362983448_image.png
esto es correccot no sera mas bien xx . xx el 2 2

18:43

Reconoci√≥ error en soluci√≥n y corrigi√≥ patr√≥n de celdas.








¬°Tienes toda la raz√≥n! Me he equivocado.

La pista 2 2 significa exactamente lo que dices: ‚ñ†‚ñ† ¬∑ ‚ñ†‚ñ† (dos llenas, hueco, dos llenas).

Lo que yo puse (¬∑ ‚ñ†‚ñ†‚ñ†‚ñ†) ser√≠an 4 celdas seguidas, que se escribir√≠a como pista 4, no 2 2.

Corrijo el ejemplo:


Corregir la soluci√≥n del coraz√≥n - la fila 2 2 debe ser ‚ñ†‚ñ† ¬∑ ‚ñ†‚ñ†
+8
-8
nonogramas_ejemplos.html

Reconsidered heart puzzle grid consistency and clues.






Ahora necesito tambi√©n ajustar las pistas de las columnas para que el coraz√≥n cuadre correctamente. D√©jame rehacer ese ejemplo completo:


Rehacer el ejemplo del coraz√≥n completo con pistas correctas
+135
-118
nonogramas_ejemplos.html

Verific√≥ y corrigi√≥ errores en las pistas del nonograma.





Un momento, d√©jame verificar que las pistas de las columnas cuadran...


12 pasos

Presented file

Verific√≥ y corrigi√≥ la soluci√≥n del crucigrama num√©rico.





¬°Corregido! Gracias por pillarme el error. Ahora el coraz√≥n tiene las pistas bien calculadas:

Soluci√≥n correcta:

       3  4  4  4  3
      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
2 2   ‚îÇ‚ñ†  ‚ñ†  ¬∑  ‚ñ†  ‚ñ†‚îÇ
5     ‚îÇ‚ñ†  ‚ñ†  ‚ñ†  ‚ñ†  ‚ñ†‚îÇ
5     ‚îÇ‚ñ†  ‚ñ†  ‚ñ†  ‚ñ†  ‚ñ†‚îÇ
3     ‚îÇ¬∑  ‚ñ†  ‚ñ†  ‚ñ†  ¬∑‚îÇ
1     ‚îÇ¬∑  ¬∑  ‚ñ†  ¬∑  ¬∑‚îÇ
      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
Las columnas 1 y 5 tienen pista 3 (no 2) porque incluyen la celda de la primera fila donde est√° el 2 2.

Buen ojo, esto precisamente es lo valioso de los nonogramas: obligan a verificar que filas y columnas cuadren. Si te equivocas en una pista, el puzzle no tiene soluci√≥n o tiene varias.

Nonogramas ejemplos
C√≥digo ¬∑ HTML 

<!DOCTYPE html> <html lang="es"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>Calcudoku con Jaulas de Colores</title> <style> body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif

pasted

vamos a crear un generador con las misma funciones que estes de calcudoku

18:50

Deline√≥ funcionalidades equivalentes para generador de Nonogramas.



Perfecto, voy a crear un generador de Nonogramas con la misma estructura y funcionalidades que tu Calcudoku. D√©jame revisar primero las mejores pr√°cticas de dise√±o.

Revisar el skill de dise√±o frontend para crear una interfaz de calidad

Dise√±√≥ generador de nonogramas replicando funcionalidades del Calcudoku.


Ahora creo el generador de Nonogramas con las mismas funcionalidades:


2 pasos

Presented file

Prepar√≥ resumen de funcionalidades implementadas para el generador.

¬°Listo! He creado el generador de Nonogramas con las mismas funcionalidades que tu Calcudoku:

Funcionalidades incluidas:

Caracter√≠stica	Descripci√≥n
Identificaci√≥n	Nombre del estudiante + logo IES Serran√≠a
Tama√±os	5√ó5, 10√ó10, 15√ó15
Dificultades	F√°cil (60% densidad), Medio (50%), Dif√≠cil (40%)
Modos de pintado	Rellenar, Marcar vac√≠a (√ó), Borrar
Controles	Clic izquierdo rellena, clic derecho marca √ó
Arrastrar	Puedes pintar arrastrando el rat√≥n
Atajos teclado	1=Rellenar, 2=Marcar, 3=Borrar
Temporizador	Cron√≥metro desde el inicio
Comprobaci√≥n	Muestra errores en rojo + porcentaje de progreso
Historial	Registro de todas las verificaciones
Vista soluci√≥n	Pantalla completa al completar
Descarga PNG	Certificado con la soluci√≥n
Modal confirmaci√≥n	Para borrar todo
Responsive	Adaptado a m√≥viles
Patrones predise√±ados:

Para 5√ó5: coraz√≥n, cruz, flecha, casa, estrella
Para 10√ó10: coraz√≥n grande, cara sonriente, √°rbol
¬øQuieres que a√±ada algo m√°s, como m√°s patrones, un modo de pistas progresivas, o alguna otra funcionalidad?

Nonogramas generator
C√≥digo ¬∑ HTML 
aparte de nonogramas que podriamos hacer +

18:59

Catalogued alternative math puzzle options aligned with workshop goals.


Buena pregunta. Aqu√≠ tienes opciones organizadas por el tipo de pensamiento que trabajan:

üî¢ L√≥gica num√©rica (estilo Sudoku/Calcudoku)
Puzzle	Descripci√≥n	Habilidad principal
Futoshiki	Sudoku + signos de desigualdad (< >) entre celdas	Ordenaci√≥n, comparaci√≥n
Killer Sudoku	Sudoku + jaulas con sumas (sin operaciones)	Combinatoria de sumas
Hidato	Conectar n√∫meros consecutivos en camino	Secuencias, planificaci√≥n
Kakuro	Crucigrama num√©rico con sumas	Descomposici√≥n de n√∫meros
Sumas cruzadas	Pir√°mides donde cada celda es suma de las dos inferiores	Operaciones b√°sicas
üß© L√≥gica pura (sin n√∫meros)
Puzzle	Descripci√≥n	Habilidad principal
Puzzle de Einstein	"El noruego vive en la primera casa..."	Deducci√≥n, tablas de verdad
Minesweeper educativo	Buscaminas con l√≥gica garantizada (sin adivinar)	Probabilidad, eliminaci√≥n
Lights Out	Apagar todas las luces (cada clic afecta adyacentes)	Pensamiento sist√©mico
Puentes (Hashiwokakero)	Conectar islas con puentes seg√∫n n√∫meros	Grafos, conectividad
Slitherlink	Crear un bucle cerrado siguiendo pistas num√©ricas	Geometr√≠a, topolog√≠a
üéØ Estrategia y teor√≠a de juegos
Puzzle	Descripci√≥n	Habilidad principal
Nim	Quitar objetos, el que coge el √∫ltimo pierde/gana	Estrategia ganadora, binario
Torres de Han√≥i	Mover discos entre postes	Recursividad, potencias de 2
Countdown	Llegar a un n√∫mero objetivo con operaciones	C√°lculo mental, creatividad
24 Game	Usar 4 n√∫meros para obtener 24	Operaciones, orden
Set	Encontrar tr√≠os con propiedades	Combinatoria, patrones
üìê Geometr√≠a y visual
Puzzle	Descripci√≥n	Habilidad principal
Tangram digital	Formar figuras con las 7 piezas	Geometr√≠a, √°reas
Pentomin√≥s	Encajar las 12 piezas en rect√°ngulos	Teselaciones, √°rea
Simetr√≠a	Completar dibujos sim√©tricos	Transformaciones
Pixel art por coordenadas	Colorear seg√∫n instrucciones (3,4)=rojo	Coordenadas cartesianas
Laberintos l√≥gicos	Solo puedes pisar m√∫ltiplos de 3, pares, etc.	Propiedades num√©ricas
üíª Pensamiento computacional
Puzzle	Descripci√≥n	Habilidad principal
Debugging visual	Encontrar el error en un "programa" gr√°fico	Algoritmos, secuencias
Robot en cuadr√≠cula	Programar movimientos para llegar a meta	Instrucciones, bucles
Ordenaci√≥n visual	Ordenar cartas con reglas limitadas (burbuja, etc.)	Algoritmos de ordenaci√≥n
Cifrado C√©sar	Descifrar mensajes con desplazamiento	Patrones, m√≥dulo
‚≠ê Mis recomendaciones para el taller
Si quieres m√°xima variedad y engagement, te sugiero estos 3:

Futoshiki ‚Üí Muy similar al Sudoku pero con desigualdades, f√°cil de entender
Countdown/24 Game ‚Üí Competitivo, r√°pido, trabaja c√°lculo mental
Puzzle de Einstein ‚Üí Diferente a todo, muy satisfactorio de resolver
¬øCu√°l te interesa que desarrolle? Puedo hacerlo con el mismo estilo que el Calcudoku y Nonogramas.

dame un ejemplo de hidato

19:00

Ide√≥ un ejemplo visual para explicar las reglas de Hidato.



Te preparo un ejemplo visual de Hidato para que veas c√≥mo funciona.


2 pasos

Presented file

Prepar√≥ explicaci√≥n introductoria sobre Hidato.

Ah√≠ tienes un ejemplo interactivo de Hidato con:

La regla es muy simple:

Rellena la cuadr√≠cula con n√∫meros del 1 al N (siendo N el total de celdas)
Cada n√∫mero debe estar adyacente al siguiente (incluidas diagonales)
Al final, puedes trazar un camino continuo del 1 al √∫ltimo n√∫mero
Lo que incluye el ejemplo:

Explicaci√≥n visual de los 8 vecinos posibles
Un puzzle 5√ó5 resuelto paso a paso
Comparaci√≥n con Sudoku (para que vean la diferencia)
Un mini-puzzle 4√ó4 interactivo para que lo pruebes t√∫ mismo
¬øPor qu√© mola para el taller?

Ventaja	Descripci√≥n
F√°cil de entender	Una sola regla: "cada n√∫mero toca al siguiente"
Visual	Puedes literalmente dibujar el camino con el dedo
Escalable	Desde 4√ó4 hasta 10√ó10 o m√°s
Diferente al Sudoku	Trabaja secuencias y planificaci√≥n, no eliminaci√≥n
Permite diagonales	Los alumnos descubren que hay 8 vecinos, no 4
¬øTe convence? Si quieres, te hago el generador completo con el mismo estilo que el Calcudoku y Nonogramas.

Hidato ejemplo
C√≥digo ¬∑ HTML 
pueden haber saltos?

19:05

Clarific√≥ reglas de Hidato y consecutividad sin saltos.





No, en Hidato no hay saltos. La cadena debe ser completamente consecutiva:

1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí 5 ‚Üí 6 ‚Üí ... ‚Üí N
Cada n√∫mero toca f√≠sicamente al siguiente en la cuadr√≠cula (en una de las 8 direcciones posibles).

Lo que puede confundir:

En el puzzle te dan algunos n√∫meros como pistas (por ejemplo: 1, 7, 11, 15, 25), pero eso no significa que haya saltos. Significa que t√∫ tienes que rellenar los que faltan para completar la cadena.

Pistas dadas:     1  ¬∑  ¬∑  7  ¬∑  ¬∑  11  ¬∑  ¬∑  15
                  ‚Üì
T√∫ rellenas:      1  2  3  4  5  6   7  8  9  10  11  12  13  14  15
Visualmente en el grid:

 [1] ‚Üí [2]             El 1 toca al 2 ‚úì
        ‚Üì              El 2 toca al 3 ‚úì
       [3] ‚Üí [4]       El 3 toca al 4 ‚úì
              ‚Üò        El 4 toca al 5 (diagonal) ‚úì
              [5]      ... y as√≠ hasta el final
Es como una serpiente de n√∫meros que recorre todo el tablero sin romper la cadena en ning√∫n momento.

¬øQuieres que te prepare el generador completo de Hidato?

1769364381622_image.png
aqui despues del 8 el 9 no es consecutivo

19:06

Verific√≥ error en soluci√≥n de Hidato y reconoci√≥ validez.






¬°Tienes toda la raz√≥n! Mirando la posici√≥n:

El 8 est√° en fila 3, columna 4
El 9 est√° en fila 4, columna 2
La distancia en columnas es 2, as√≠ que no se tocan. Mi soluci√≥n est√° mal.

Deja que corrija el ejemplo con una soluci√≥n v√°lida:


Corregir la soluci√≥n del Hidato 5x5 para que sea v√°lida
+34
-34
hidato_ejemplo.html

Redise√±√≥ completamente el puzzle para validar la soluci√≥n.
24s











Espera, d√©jame verificar toda la soluci√≥n corregida. Creo que a√∫n tiene errores. Necesito rehacer el puzzle completo con una soluci√≥n v√°lida:


Rehacer completamente el ejemplo de Hidato con soluci√≥n verificada
+73
-73
hidato_ejemplo.html

Verific√≥ exhaustivamente una soluci√≥n de camino num√©rico completo.




Ahora verifico el camino completo de la nueva soluci√≥n:

 1 ‚Üí  2                    22 ‚Üí 23      25
      ‚Üì                   ‚Üó       ‚Üò    ‚Üë
 4 ‚Üê  3      20 ‚Üê 21 ‚Üê 24
 ‚Üì           ‚Üë       
 5 ‚Üí  6 ‚Üí  7      19 ‚Üí 18
             ‚Üì    ‚Üë       ‚Üë
10 ‚Üê  9 ‚Üê  8     14 ‚Üí 17
 ‚Üì               ‚Üë       ‚Üë
11 ‚Üí 12 ‚Üí 13 ‚Üí 15 ‚Üí 16
Verificaci√≥n de adyacencias cr√≠ticas:

7‚Üí8: (fila 2, col 2) ‚Üí (fila 3, col 2) ‚úì vertical
8‚Üí9: (fila 3, col 2) ‚Üí (fila 3, col 1) ‚úì horizontal
13‚Üí14: (fila 4, col 2) ‚Üí (fila 3, col 3) ‚úì diagonal
19‚Üí20: (fila 2, col 3) ‚Üí (fila 1, col 2) ‚úì diagonal
21‚Üí22: (fila 1, col 3) ‚Üí (fila 0, col 2) ‚úì diagonal
23‚Üí24: (fila 0, col 3) ‚Üí (fila 1, col 4) ‚úì diagonal

Presented file

Verific√≥ y corrigi√≥ la soluci√≥n de n√∫meros consecutivos.

¬°Corregido! Ahora la soluci√≥n es v√°lida. Cada n√∫mero toca al siguiente:

Soluci√≥n corregida:

 1   2  22  23  25
 4   3  20  21  24
 5   6   7  19  18
10   9   8  14  17
11  12  13  15  16
El camino ahora va: 1‚Üí2‚Üí3‚Üí4‚Üí5‚Üí6‚Üí7‚Üí8‚Üí9‚Üí10‚Üí11‚Üí12‚Üí13‚Üí14‚Üí15‚Üí16‚Üí17‚Üí18‚Üí19‚Üí20‚Üí21‚Üí22‚Üí23‚Üí24‚Üí25

La clave estaba en que el 13‚Üí14 es un salto diagonal desde (fila 4, col 2) a (fila 3, col 3), y luego 14‚Üí15 baja a (fila 4, col 3).

Gracias por el ojo cr√≠tico, eso es exactamente lo que hace Hidato interesante: hay que verificar que el camino no se rompa en ning√∫n punto.

¬øQuieres que te haga el generador completo de Hidato?

Hidato ejemplo
C√≥digo ¬∑ HTML 
el ejerciocio es irresolubles pues pones dos numeros consecutivos a mas de una casilla

19:10

Verific√≥ la soluci√≥n del puzzle y cuestion√≥ la validez del reclamo.
20s











Tienes raz√≥n, d√©jame revisar. ¬øCu√°l par de n√∫meros consecutivos ves que est√°n a m√°s de una casilla?

Revisando mi soluci√≥n propuesta:

Posiciones (fila, columna):

 1(0,0)   2(0,1)  22(0,2)  23(0,3)  25(0,4)
 4(1,0)   3(1,1)  20(1,2)  21(1,3)  24(1,4)
 5(2,0)   6(2,1)   7(2,2)  19(2,3)  18(2,4)
10(3,0)   9(3,1)   8(3,2)  14(3,3)  17(3,4)
11(4,0)  12(4,1)  13(4,2)  15(4,3)  16(4,4)
El que me preocupa es 13‚Üí14‚Üí15:

13 est√° en (4,2)
14 est√° en (3,3) ‚Äî diagonal de 13 ‚úì
15 est√° en (4,3) ‚Äî debajo de 14 ‚úì
¬øVes otro salto inv√°lido? Dime cu√°l par y lo corrijo. Es posible que se me haya escapado alguno o que haya un error en c√≥mo se muestra en el HTML.

la disposicion del 14 por donde esta el 7 obliga a hacer la diagonal y al final se queda un hueco vacio al cual no se puede volver si todo es una secuencoi

19:12

Reconoci√≥ la imposibilidad del puzzle y planific√≥ soluci√≥n v√°lida.
32s














Tienes toda la raz√≥n. D√©jame analizar el problema:

Pistas dadas:

1 en (0,0), 25 en (0,4)
3 en (1,1), 21 en (1,3)
7 en (2,2)
9 en (3,1), 14 en (3,3)
11 en (4,0), 16 en (4,4)
El problema:

Entre el 7 y el 14 hay que meter 8, 9, 10, 11, 12, 13 (seis n√∫meros). Pero el 9 ya est√° fijado en (3,1) y el 11 en (4,0). Esto fuerza el camino a bajar por la izquierda.

Luego tiene que volver a subir hasta el 14 en (3,3), seguir al 16 en (4,4), subir al 21 en (1,3), y llegar al 25 en (0,4).

Con esta disposici√≥n, quedan celdas "atrapadas" en la zona superior (alrededor de fila 0-1, columnas 2-3) a las que el camino no puede llegar sin romper la secuencia.

El puzzle es irresoluble.

Tienes buen ojo. Para hacer un Hidato v√°lido hay que:

Primero dibujar el camino completo (1‚Üí2‚Üí3‚Üí...‚Üí25)
Despu√©s quitar algunos n√∫meros como pistas
As√≠ se garantiza que siempre tiene soluci√≥n. ¬øQuieres que rehaga el ejemplo con un puzzle que s√≠ funcione?

1769364794224_image.png
1769364842264_image.png
en la segunda es una posible solucion con un salto

19:14

Verific√≥ la soluci√≥n y confirm√≥ el salto entre n√∫meros.
14s









¬°Exacto! Veo el salto:

13 ‚Üí 14

El 13 est√° en (3,3) ‚Äî esquina inferior derecha
El 14 est√° en (1,1) ‚Äî centro izquierda
Distancia: 2 filas y 2 columnas = NO son adyacentes

Me has pillado dos veces. Tanto el ejemplo 5√ó5 como el puzzle interactivo 4√ó4 est√°n mal dise√±ados porque los hice "a ojo" en lugar de hacerlo bien.

La forma correcta de crear un Hidato:

Primero dibujar el camino completo del 1 al N
Luego quitar n√∫meros para crear las pistas
Nunca colocar pistas aleatorias y esperar que encajen.

Voy a corregir el ejemplo con puzzles v√°lidos. Dame un momento:


Rehacer el Hidato con puzzles correctamente dise√±ados - primero el camino, luego las pistas
+73
-73
hidato_ejemplo.html

Construy√≥ y valid√≥ un camino num√©rico v√°lido para puzzle.
22s








Espera, d√©jame verificar mi nueva soluci√≥n antes de guardarla... Hay un error en 16‚Üí17‚Üí18. Voy a dise√±arlo correctamente:


Crear un Hidato 5x5 correctamente dise√±ado - camino primero verificado
+73
-73
hidato_ejemplo.html

Verific√≥ meticulosamente la validez del camino num√©rico.





Ahora verifico el camino de la nueva soluci√≥n:

 1   2   3  25  24
 6   5   4  22  23
 7   8  21  20  19
10   9  14  15  18
11  12  13  16  17
Verificaci√≥n paso a paso:

1‚Üí2‚Üí3: horizontal ‚úì
3‚Üí4: vertical abajo ‚úì
4‚Üí5‚Üí6: horizontal izquierda ‚úì
6‚Üí7: vertical abajo ‚úì
7‚Üí8: horizontal derecha ‚úì
8‚Üí9: vertical abajo ‚úì
9‚Üí10: horizontal izquierda ‚úì
10‚Üí11: vertical abajo ‚úì
11‚Üí12‚Üí13: horizontal derecha ‚úì
13‚Üí14: vertical arriba ‚úì
14‚Üí15: horizontal derecha ‚úì
15‚Üí16: vertical abajo ‚úì
16‚Üí17: horizontal derecha ‚úì
17‚Üí18: vertical arriba ‚úì
18‚Üí19: vertical arriba ‚úì
19‚Üí20‚Üí21: horizontal izquierda ‚úì
21‚Üí22: diagonal arriba-derecha ‚úì
22‚Üí23: horizontal derecha ‚úì
23‚Üí24: vertical arriba ‚úì
24‚Üí25: horizontal izquierda ‚úì
¬°Todos adyacentes! Ahora corrijo tambi√©n el puzzle interactivo 4√ó4:


Corregir el puzzle interactivo 4x4 con una soluci√≥n v√°lida
+19
-18
hidato_ejemplo.html

Dise√±√≥ patr√≥n de serpiente v√°lido para puzzle 4x4.









Espera, verifico el 4√ó4:

 1   2   3   4
16  15   6   5
14   8   7   9
13  12  11  10
7‚Üí8: (2,2) ‚Üí (2,1) ‚úì 8‚Üí9: (2,1) ‚Üí (2,3) ‚Äî ¬°distancia 2 columnas! ‚ùå

Otra vez mal. D√©jame hacerlo con un patr√≥n serpiente que s√© que funciona:


Puzzle 4x4 con patr√≥n serpiente - 100% v√°lido
+19
-19
hidato_ejemplo.html

Verific√≥ exhaustivamente la validez del patr√≥n serpiente.



Verificaci√≥n del patr√≥n serpiente 4√ó4:

 1 ‚Üí 2 ‚Üí 3 ‚Üí 4
               ‚Üì
 8 ‚Üê 7 ‚Üê 6 ‚Üê 5
 ‚Üì
 9 ‚Üí10 ‚Üí11 ‚Üí12
               ‚Üì
16 ‚Üê15 ‚Üê14 ‚Üê13
Todos los movimientos son horizontales o verticales (1 celda). ‚úì


Presented file

Reconoci√≥ error en puzzle y valid√≥ soluciones alternativas.


¬°Ahora s√≠! Ambos puzzles est√°n corregidos:

5√ó5 - Camino verificado:

 1 ‚Üí 2 ‚Üí 3          25‚Üê24
         ‚Üì          ‚Üë    ‚Üë
 6 ‚Üê 5 ‚Üê 4    22‚Üí23
 ‚Üì          ‚Üó
 7 ‚Üí 8    21‚Üê20‚Üê19
     ‚Üì          ‚Üë
10‚Üê 9    14‚Üí15  18
 ‚Üì          ‚Üì   ‚Üë
11‚Üí12‚Üí13  16‚Üí17
4√ó4 - Patr√≥n serpiente (el m√°s sencillo):

 1 ‚Üí 2 ‚Üí 3 ‚Üí 4
               ‚Üì
 8 ‚Üê 7 ‚Üê 6 ‚Üê 5
 ‚Üì
 9 ‚Üí10 ‚Üí11 ‚Üí12
               ‚Üì
16 ‚Üê15 ‚Üê14 ‚Üê13
Gracias por la paciencia verificando. Esto demuestra por qu√© el generador de Hidato tiene que construir primero el camino completo y despu√©s quitar n√∫meros como pistas, nunca al rev√©s.

¬øQuieres que haga el generador completo ahora que entiendo bien las restricciones?

Hidato ejemplo
C√≥digo ¬∑ HTML 
me gustaria un generador del mimso estilo que el anterior

19:16

Dise√±√≥ generador Hidato completo con validaci√≥n de puzzles resolubles.




Perfecto, voy a crear el generador de Hidato con el mismo estilo que el Calcudoku.


2 pasos

Presented file

Verific√≥ creaci√≥n y prepar√≥ explicaci√≥n de caracter√≠sticas.

¬°Listo! He creado el generador de Hidato con el mismo estilo que el Calcudoku:

Funcionalidades incluidas:

Caracter√≠stica	Descripci√≥n
Identificaci√≥n	Nombre del estudiante + logo IES Serran√≠a
Tama√±os	4√ó4, 5√ó5, 6√ó6, 7√ó7, 8√ó8
Dificultades	F√°cil (50% pistas), Medio (35%), Dif√≠cil (25%)
Temporizador	Cron√≥metro desde el inicio
Teclado num√©rico	Botones para colocar n√∫meros (se desactivan los ya usados)
Teclado f√≠sico	N√∫meros + flechas para navegar
Verificaci√≥n	Comprueba adyacencia de cada par consecutivo
Historial	Registro de todas las verificaciones
Vista soluci√≥n	Pantalla completa al completar
Descarga PNG	Certificado con la soluci√≥n
Modal confirmaci√≥n	Para borrar todo
Responsive	Adaptado a m√≥viles
Lo m√°s importante - Generaci√≥n garantizada:

El generador usa el algoritmo de Warnsdorff (el mismo que se usa para el problema del caballo de ajedrez) para crear primero un camino v√°lido que pasa por todas las celdas. Despu√©s selecciona qu√© n√∫meros mostrar como pistas.

Esto garantiza que todos los puzzles tienen soluci√≥n y nunca habr√° saltos imposibles como en mis ejemplos anteriores mal hechos.

¬øQuieres que a√±ada algo m√°s o que hagamos otro tipo de puzzle?

Hidato generator
C√≥digo ¬∑ HTML 





Claude es IA y puede cometer errores. Por favor, verifica las respuestas.
Hidato generator ¬∑ HTML
Copiar

<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hidato - IES Serran√≠a</title>
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
            color: #333;
        }
        h1, h2 {
            color: #2c3e50;
            text-align: center;
        }
        .user-container {
            background-color: #fff;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            text-align: center;
        }
        .user-container h2 {
            margin-top: 0;
            color: #3498db;
        }
        .user-form {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin: 15px 0;
            flex-wrap: wrap;
        }
        .user-form input {
            padding: 8px 12px;
            border-radius: 5px;
            border: 1px solid #ccc;
            width: 200px;
        }
        .center-logo {
            text-align: center;
            margin: 15px 0;
        }
        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        select, button {
            padding: 8px 12px;
            border-radius: 5px;
            border: 1px solid #ccc;
            background-color: white;
            font-size: 16px;
        }
        button {
            background-color: #3498db;
            color: white;
            border: none;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #2980b9;
        }
        .danger-btn {
            background-color: #e74c3c;
        }
        .danger-btn:hover {
            background-color: #c0392b;
        }
        .success-btn {
            background-color: #27ae60;
        }
        .success-btn:hover {
            background-color: #219653;
        }
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #capture-area {
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            max-width: 100%;
        }
        .timer-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 10px 0;
            font-size: 1.5em;
            font-weight: bold;
            color: #2c3e50;
        }
        .message {
            font-size: 1.2em;
            font-weight: bold;
            text-align: center;
            margin: 10px 0;
            min-height: 30px;
        }
        .success {
            color: #27ae60;
        }
        .error {
            color: #e74c3c;
        }
        .info {
            color: #3498db;
        }

        /* Grid de Hidato */
        .hidato {
            display: grid;
            border: 3px solid #2c3e50;
            margin: 20px auto;
            border-radius: 5px;
            overflow: hidden;
        }
        .cell {
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: white;
            font-size: 1.4em;
            font-weight: bold;
            cursor: pointer;
            border: 1px solid #bdc3c7;
            transition: background-color 0.2s;
            position: relative;
        }
        .cell:hover:not(.given) {
            background-color: #ebf5fb;
        }
        .cell.given {
            background-color: #3498db;
            color: white;
            cursor: default;
        }
        .cell.selected {
            background-color: #f39c12 !important;
            color: white;
        }
        .cell.filled {
            background-color: #e8f8f5;
            color: #1abc9c;
        }
        .cell.error {
            background-color: #e74c3c !important;
            color: white;
            animation: shake 0.3s;
        }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-3px); }
            75% { transform: translateX(3px); }
        }
        .cell-input {
            width: 100%;
            height: 100%;
            border: none;
            text-align: center;
            font-size: 1.2em;
            font-weight: bold;
            background: transparent;
            cursor: pointer;
            color: inherit;
        }
        .cell-input:focus {
            outline: none;
        }
        .cell-input::placeholder {
            color: #ccc;
        }

        /* Teclado num√©rico */
        .number-pad {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 8px;
            max-width: 350px;
            margin: 20px auto;
        }
        .number-btn {
            width: 45px;
            height: 45px;
            font-size: 1.3em;
            border-radius: 8px;
            border: none;
            background-color: #3498db;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            transition: all 0.2s;
        }
        .number-btn:hover {
            background-color: #2980b9;
            transform: translateY(-2px);
        }
        .number-btn:active {
            transform: translateY(0);
        }
        .number-btn.used {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }
        .number-btn.used:hover {
            transform: none;
        }
        .delete-btn {
            background-color: #e74c3c;
        }
        .delete-btn:hover {
            background-color: #c0392b;
        }

        /* Historial de verificaciones */
        .verification-history {
            background-color: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
            margin-top: 15px;
            max-height: 200px;
            overflow-y: auto;
            font-size: 0.9em;
            color: #555;
        }
        .verification-history h3 {
            margin-top: 0;
            margin-bottom: 8px;
            color: #3498db;
            font-size: 1em;
            border-bottom: 1px solid #ddd;
            padding-bottom: 5px;
        }
        .verification-history p {
            margin: 5px 0;
        }

        /* Leyenda */
        .legend {
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            font-size: 0.9em;
        }
        .legend h3 {
            margin-top: 0;
            color: #2c3e50;
            font-size: 1em;
        }
        .legend p {
            margin: 8px 0;
            line-height: 1.5;
        }
        .legend-color {
            display: inline-block;
            width: 20px;
            height: 20px;
            border-radius: 3px;
            vertical-align: middle;
            margin-right: 5px;
            border: 1px solid #333;
        }
        .legend-color.given {
            background-color: #3498db;
        }
        .legend-color.filled {
            background-color: #e8f8f5;
        }

        /* Modal de confirmaci√≥n */
        .confirm-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }
        .confirm-modal.show {
            display: flex;
        }
        .confirm-dialog {
            background-color: white;
            border-radius: 10px;
            padding: 20px;
            max-width: 90%;
            width: 350px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        .confirm-dialog h3 {
            margin-top: 0;
            color: #e74c3c;
            text-align: center;
        }
        .confirm-dialog p {
            margin: 15px 0;
            text-align: center;
            font-size: 1.1em;
        }
        .confirm-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        .confirm-buttons button {
            flex: 1;
            padding: 12px;
            font-size: 1.1em;
            border-radius: 5px;
            border: none;
            cursor: pointer;
        }
        .confirm-yes {
            background-color: #e74c3c;
            color: white;
        }
        .confirm-yes:hover {
            background-color: #c0392b;
        }
        .confirm-no {
            background-color: #95a5a6;
            color: white;
        }
        .confirm-no:hover {
            background-color: #7f8c8d;
        }

        /* Vista de soluci√≥n */
        .solution-view {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: white;
            z-index: 1000;
            padding: 20px;
            overflow: auto;
            display: none;
        }
        .solution-header {
            text-align: left;
            margin-bottom: 20px;
            color: #2c3e50;
            line-height: 1.6;
        }
        .solution-header h2 {
            text-align: center;
            margin-bottom: 20px;
        }
        .solution-info {
            margin-bottom: 10px;
        }
        .solution-grid-container {
            display: flex;
            justify-content: center;
            width: 100%;
            margin: 30px 0;
        }
        .solution-grid {
            display: grid;
            border: 3px solid #2c3e50;
            margin: 0 auto;
            border-radius: 5px;
            overflow: hidden;
        }
        .solution-cell {
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 1.1em;
            border: 1px solid #bdc3c7;
        }
        .solution-cell.given {
            background-color: #3498db;
            color: white;
        }
        .solution-cell.filled {
            background-color: #e8f8f5;
            color: #1abc9c;
        }
        .solution-message {
            text-align: center;
            font-size: 1.5em;
            font-weight: bold;
            margin: 20px 0;
        }
        .solution-message.success {
            color: #27ae60;
        }
        .solution-message.error {
            color: #e74c3c;
        }
        .close-solution {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: #e74c3c;
            color: white;
            border: none;
            border-radius: 5px;
            padding: 5px 10px;
            cursor: pointer;
        }
        .download-solution {
            display: block;
            background-color: #27ae60;
            color: white;
            border: none;
            border-radius: 5px;
            padding: 10px 15px;
            cursor: pointer;
            font-size: 1em;
            margin: 20px auto;
        }
        .download-solution:hover {
            background-color: #219653;
        }
        .solution-verification {
            margin-top: 20px;
        }
        .solution-verification h3 {
            color: #3498db;
            border-bottom: 1px solid #ddd;
            padding-bottom: 5px;
            margin-bottom: 10px;
        }
        .verification-item {
            margin: 8px 0;
            padding-left: 20px;
            position: relative;
        }
        .verification-item:before {
            content: "‚Ä¢";
            position: absolute;
            left: 5px;
        }
        .verification-item.success:before {
            color: #27ae60;
        }
        .verification-item.error:before {
            color: #e74c3c;
        }

        /* Link oculto para descarga */
        #download-link {
            display: none;
        }

        /* Responsive */
        @media (max-width: 600px) {
            body {
                padding: 10px;
            }
            .cell {
                font-size: 1em;
            }
            .number-btn {
                width: 38px;
                height: 38px;
                font-size: 1.1em;
            }
            .controls {
                flex-direction: column;
                align-items: center;
            }
            select, button {
                width: 100%;
                max-width: 200px;
                margin-bottom: 5px;
            }
        }

        @media (max-width: 400px) {
            .cell {
                font-size: 0.9em;
            }
            .number-btn {
                width: 32px;
                height: 32px;
                font-size: 1em;
            }
        }

        @media print {
            body * {
                visibility: hidden;
            }
            .solution-view, .solution-view * {
                visibility: visible;
            }
            .solution-view {
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                background: white;
                padding: 20px;
                margin: 0;
            }
            .close-solution, .download-solution {
                display: none;
            }
        }
    </style>
</head>
<body>
    <h1>üî¢ Hidato</h1>
    
    <!-- Secci√≥n de identificaci√≥n del usuario -->
    <div class="user-container">
        <div class="center-logo">
            <h2>IES Serran√≠a</h2>
            <p>Departamento de Matem√°ticas - STEAM 4.0</p>
        </div>
        <div class="user-form">
            <label for="username">Nombre:</label>
            <input type="text" id="username" placeholder="Introduce tu nombre">
            <button id="start-game" type="button">Comenzar</button>
        </div>
    </div>
    
    <div id="game-section" style="display: none;">
        <div class="controls">
            <select id="size">
                <option value="4">4√ó4</option>
                <option value="5">5√ó5</option>
                <option value="6" selected>6√ó6</option>
                <option value="7">7√ó7</option>
                <option value="8">8√ó8</option>
            </select>
            <select id="difficulty">
                <option value="easy">F√°cil</option>
                <option value="medium" selected>Medio</option>
                <option value="hard">Dif√≠cil</option>
            </select>
            <button id="new-game" type="button">Nuevo Juego</button>
            <button id="check" type="button" class="success-btn">Comprobar</button>
            <button id="clear-all" type="button" class="danger-btn">Borrar Todo</button>
        </div>
        
        <div id="capture-area">
            <div class="timer-container">
                Tiempo: <span id="timer">00:00</span>
            </div>
            
            <div class="game-container">
                <div id="hidato" class="hidato"></div>
                <div id="message" class="message"></div>
            </div>
        </div>
        
        <!-- Teclado num√©rico -->
        <div class="number-pad" id="number-pad">
            <!-- Se genera din√°micamente -->
        </div>
        
        <!-- Leyenda -->
        <div class="legend">
            <h3>üìñ C√≥mo jugar:</h3>
            <p>Rellena la cuadr√≠cula con n√∫meros del 1 al N de forma que <strong>cada n√∫mero toque al siguiente</strong> (horizontal, vertical o diagonal).</p>
            <p><span class="legend-color given"></span> N√∫meros fijos (pistas)</p>
            <p><span class="legend-color filled"></span> N√∫meros que has colocado</p>
            <p><strong>Consejo:</strong> Empieza conectando los n√∫meros fijos que est√©n cerca.</p>
        </div>
        
        <!-- Historial de verificaciones -->
        <div class="verification-history">
            <h3>Historial de verificaciones:</h3>
            <div id="verification-list"></div>
        </div>
    </div>

    <!-- Modal de confirmaci√≥n -->
    <div id="confirm-modal" class="confirm-modal">
        <div class="confirm-dialog">
            <h3>‚ö†Ô∏è Confirmar borrado</h3>
            <p id="confirm-message">¬øEst√°s seguro de que quieres borrar todas las celdas?</p>
            <div class="confirm-buttons">
                <button id="confirm-no" type="button" class="confirm-no">No, cancelar</button>
                <button id="confirm-yes" type="button" class="confirm-yes">S√≠, borrar</button>
            </div>
        </div>
    </div>

    <!-- Vista de soluci√≥n -->
    <div id="solution-view" class="solution-view">
        <button id="close-solution" type="button" class="close-solution">X</button>
        <div class="solution-header">
            <h2 id="solution-title">IES Serran√≠a - Hidato</h2>
            <div class="solution-info" id="solution-info"></div>
        </div>
        <div class="solution-grid-container">
            <div id="solution-grid" class="solution-grid"></div>
        </div>
        <div id="solution-message" class="solution-message success"></div>
        <div class="solution-verification">
            <h3>Historial de verificaciones:</h3>
            <div id="solution-verification-list"></div>
        </div>
        <button id="download-solution" type="button" class="download-solution">üì• Descargar PNG</button>
    </div>

    <!-- Link oculto para descarga -->
    <a id="download-link" download="hidato.png"></a>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Variables globales
            let size = 6;
            let difficulty = 'medium';
            let solution = [];       // Matriz con la soluci√≥n completa
            let givenCells = [];     // Celdas con pistas fijas
            let playerBoard = [];    // Lo que el jugador ha puesto
            let selectedCell = null;
            let timerInterval = null;
            let startTime = null;
            let username = '';
            let verificationHistory = [];

            // Referencias DOM
            const hidatoEl = document.getElementById('hidato');
            const messageEl = document.getElementById('message');
            const sizeEl = document.getElementById('size');
            const difficultyEl = document.getElementById('difficulty');
            const newGameBtn = document.getElementById('new-game');
            const checkBtn = document.getElementById('check');
            const clearAllBtn = document.getElementById('clear-all');
            const numberPadEl = document.getElementById('number-pad');
            const timerEl = document.getElementById('timer');
            const usernameInput = document.getElementById('username');
            const startGameBtn = document.getElementById('start-game');
            const gameSection = document.getElementById('game-section');
            const userContainer = document.querySelector('.user-container');
            const verificationList = document.getElementById('verification-list');
            
            const confirmModal = document.getElementById('confirm-modal');
            const confirmMessage = document.getElementById('confirm-message');
            const confirmYesBtn = document.getElementById('confirm-yes');
            const confirmNoBtn = document.getElementById('confirm-no');
            
            const solutionView = document.getElementById('solution-view');
            const solutionTitle = document.getElementById('solution-title');
            const solutionInfo = document.getElementById('solution-info');
            const solutionGrid = document.getElementById('solution-grid');
            const solutionMessage = document.getElementById('solution-message');
            const solutionVerificationList = document.getElementById('solution-verification-list');
            const closeSolutionBtn = document.getElementById('close-solution');
            const downloadSolutionBtn = document.getElementById('download-solution');
            const downloadLink = document.getElementById('download-link');

            // Event Listeners
            startGameBtn.addEventListener('click', function(e) {
                e.preventDefault();
                username = usernameInput.value.trim();
                if (!username) {
                    alert('Por favor, introduce tu nombre para comenzar.');
                    return;
                }
                userContainer.style.display = 'none';
                gameSection.style.display = 'block';
                initGame();
            });

            newGameBtn.addEventListener('click', function(e) {
                e.preventDefault();
                initGame();
            });

            checkBtn.addEventListener('click', function(e) {
                e.preventDefault();
                checkSolution();
            });

            clearAllBtn.addEventListener('click', function(e) {
                e.preventDefault();
                clearAllCells();
            });

            sizeEl.addEventListener('change', function() {
                size = parseInt(this.value);
                initGame();
            });

            difficultyEl.addEventListener('change', function() {
                difficulty = this.value;
                initGame();
            });

            closeSolutionBtn.addEventListener('click', function() {
                solutionView.style.display = 'none';
            });

            downloadSolutionBtn.addEventListener('click', function() {
                captureAndDownloadPng();
            });

            // Modal
            let currentConfirmCallback = null;
            
            function showConfirmModal(message, onConfirm) {
                confirmMessage.textContent = message;
                confirmModal.classList.add('show');
                currentConfirmCallback = onConfirm;
            }
            
            confirmYesBtn.addEventListener('click', function() {
                confirmModal.classList.remove('show');
                if (currentConfirmCallback) {
                    currentConfirmCallback();
                    currentConfirmCallback = null;
                }
            });
            
            confirmNoBtn.addEventListener('click', function() {
                confirmModal.classList.remove('show');
                currentConfirmCallback = null;
                messageEl.textContent = 'Borrado cancelado.';
                messageEl.className = 'message info';
            });

            confirmModal.addEventListener('click', function(e) {
                if (e.target === confirmModal) {
                    confirmModal.classList.remove('show');
                    currentConfirmCallback = null;
                }
            });

            // ===== GENERACI√ìN DEL PUZZLE =====
            
            function initGame() {
                messageEl.textContent = 'Generando puzzle...';
                messageEl.className = 'message info';
                verificationHistory = [];
                verificationList.innerHTML = '';
                selectedCell = null;

                setTimeout(() => {
                    // 1. Generar un camino hamiltoniano v√°lido
                    solution = generateHamiltonianPath();
                    
                    // 2. Seleccionar qu√© celdas mostrar como pistas
                    givenCells = selectGivenCells();
                    
                    // 3. Inicializar tablero del jugador
                    playerBoard = Array(size).fill().map(() => Array(size).fill(0));
                    for (const [row, col] of givenCells) {
                        playerBoard[row][col] = solution[row][col];
                    }
                    
                    // 4. Renderizar
                    renderBoard();
                    createNumberPad();
                    startTimer();
                    
                    messageEl.textContent = '';
                    
                    const difficultyMap = {
                        'easy': 'F√°cil',
                        'medium': 'Medio',
                        'hard': 'Dif√≠cil'
                    };
                    addVerification(`Nuevo juego: ${size}√ó${size}, dificultad ${difficultyMap[difficulty]}`, 'success');
                }, 100);
            }

            // Genera un camino que pasa por todas las celdas exactamente una vez
            function generateHamiltonianPath() {
                const total = size * size;
                let path = null;
                let attempts = 0;
                const maxAttempts = 100;

                while (!path && attempts < maxAttempts) {
                    attempts++;
                    path = tryGeneratePath();
                }

                if (!path) {
                    // Fallback: usar patr√≥n serpiente
                    path = generateSnakePath();
                }

                // Convertir path a matriz
                const matrix = Array(size).fill().map(() => Array(size).fill(0));
                for (let i = 0; i < path.length; i++) {
                    const [row, col] = path[i];
                    matrix[row][col] = i + 1;
                }

                return matrix;
            }

            function tryGeneratePath() {
                const total = size * size;
                const visited = Array(size).fill().map(() => Array(size).fill(false));
                const path = [];

                // Empezar desde una esquina aleatoria
                const corners = [[0, 0], [0, size-1], [size-1, 0], [size-1, size-1]];
                const start = corners[Math.floor(Math.random() * corners.length)];
                
                path.push(start);
                visited[start[0]][start[1]] = true;

                if (buildPath(path, visited, total)) {
                    return path;
                }
                return null;
            }

            function buildPath(path, visited, total) {
                if (path.length === total) {
                    return true;
                }

                const [row, col] = path[path.length - 1];
                const neighbors = getNeighbors(row, col);
                
                // Ordenar vecinos por n√∫mero de opciones (Warnsdorff's rule)
                neighbors.sort((a, b) => {
                    const optionsA = countUnvisitedNeighbors(a[0], a[1], visited);
                    const optionsB = countUnvisitedNeighbors(b[0], b[1], visited);
                    return optionsA - optionsB;
                });

                // A√±adir algo de aleatoriedad
                if (Math.random() < 0.3 && neighbors.length > 1) {
                    const i = Math.floor(Math.random() * Math.min(2, neighbors.length));
                    [neighbors[0], neighbors[i]] = [neighbors[i], neighbors[0]];
                }

                for (const [nRow, nCol] of neighbors) {
                    if (!visited[nRow][nCol]) {
                        visited[nRow][nCol] = true;
                        path.push([nRow, nCol]);

                        if (buildPath(path, visited, total)) {
                            return true;
                        }

                        path.pop();
                        visited[nRow][nCol] = false;
                    }
                }

                return false;
            }

            function getNeighbors(row, col) {
                const neighbors = [];
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        if (dr === 0 && dc === 0) continue;
                        const nRow = row + dr;
                        const nCol = col + dc;
                        if (nRow >= 0 && nRow < size && nCol >= 0 && nCol < size) {
                            neighbors.push([nRow, nCol]);
                        }
                    }
                }
                return neighbors;
            }

            function countUnvisitedNeighbors(row, col, visited) {
                let count = 0;
                for (const [nRow, nCol] of getNeighbors(row, col)) {
                    if (!visited[nRow][nCol]) count++;
                }
                return count;
            }

            function generateSnakePath() {
                const path = [];
                for (let row = 0; row < size; row++) {
                    if (row % 2 === 0) {
                        for (let col = 0; col < size; col++) {
                            path.push([row, col]);
                        }
                    } else {
                        for (let col = size - 1; col >= 0; col--) {
                            path.push([row, col]);
                        }
                    }
                }
                return path;
            }

            function selectGivenCells() {
                const total = size * size;
                const given = [];
                
                // Determinar porcentaje de pistas seg√∫n dificultad
                let percentage;
                switch (difficulty) {
                    case 'easy': percentage = 0.5; break;
                    case 'medium': percentage = 0.35; break;
                    case 'hard': percentage = 0.25; break;
                    default: percentage = 0.35;
                }

                const numGiven = Math.max(4, Math.floor(total * percentage));

                // Siempre incluir el 1 y el √∫ltimo n√∫mero
                const firstPos = findNumberPosition(1);
                const lastPos = findNumberPosition(total);
                given.push(firstPos);
                given.push(lastPos);

                // Incluir algunos n√∫meros clave distribuidos
                const keyNumbers = [];
                const step = Math.floor(total / (numGiven - 2));
                for (let n = step; n < total; n += step) {
                    keyNumbers.push(n);
                }

                // A√±adir n√∫meros clave
                for (const num of keyNumbers) {
                    if (given.length >= numGiven) break;
                    const pos = findNumberPosition(num);
                    if (!given.some(([r, c]) => r === pos[0] && c === pos[1])) {
                        given.push(pos);
                    }
                }

                // Rellenar con n√∫meros aleatorios si hace falta
                const allPositions = [];
                for (let row = 0; row < size; row++) {
                    for (let col = 0; col < size; col++) {
                        allPositions.push([row, col]);
                    }
                }
                shuffleArray(allPositions);

                for (const pos of allPositions) {
                    if (given.length >= numGiven) break;
                    if (!given.some(([r, c]) => r === pos[0] && c === pos[1])) {
                        given.push(pos);
                    }
                }

                return given;
            }

            function findNumberPosition(num) {
                for (let row = 0; row < size; row++) {
                    for (let col = 0; col < size; col++) {
                        if (solution[row][col] === num) {
                            return [row, col];
                        }
                    }
                }
                return null;
            }

            function shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }

            // ===== RENDERIZADO =====

            function renderBoard() {
                hidatoEl.innerHTML = '';
                
                // Tama√±o de celda
                let cellSize;
                if (size <= 5) cellSize = 55;
                else if (size <= 6) cellSize = 50;
                else if (size <= 7) cellSize = 45;
                else cellSize = 40;

                if (window.innerWidth <= 600) {
                    cellSize = Math.min(cellSize, Math.floor((window.innerWidth - 60) / size));
                }

                hidatoEl.style.gridTemplateColumns = `repeat(${size}, ${cellSize}px)`;
                hidatoEl.style.gridTemplateRows = `repeat(${size}, ${cellSize}px)`;

                for (let row = 0; row < size; row++) {
                    for (let col = 0; col < size; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.dataset.row = row;
                        cell.dataset.col = col;
                        cell.style.width = cellSize + 'px';
                        cell.style.height = cellSize + 'px';

                        const isGiven = givenCells.some(([r, c]) => r === row && c === col);
                        
                        if (isGiven) {
                            cell.classList.add('given');
                            cell.textContent = solution[row][col];
                        } else {
                            if (playerBoard[row][col] !== 0) {
                                cell.textContent = playerBoard[row][col];
                                cell.classList.add('filled');
                            }
                            
                            cell.addEventListener('click', function() {
                                selectCellHandler(row, col);
                            });
                        }

                        hidatoEl.appendChild(cell);
                    }
                }
            }

            function selectCellHandler(row, col) {
                // Deseleccionar anterior
                document.querySelectorAll('.cell.selected').forEach(c => c.classList.remove('selected'));
                
                const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
                cell.classList.add('selected');
                selectedCell = [row, col];
            }

            function createNumberPad() {
                numberPadEl.innerHTML = '';
                const total = size * size;

                for (let i = 1; i <= total; i++) {
                    const btn = document.createElement('button');
                    btn.className = 'number-btn';
                    btn.type = 'button';
                    btn.textContent = i;
                    btn.dataset.num = i;
                    
                    btn.addEventListener('click', function(e) {
                        e.preventDefault();
                        placeNumber(i);
                    });
                    
                    numberPadEl.appendChild(btn);
                }

                // Bot√≥n borrar
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'number-btn delete-btn';
                deleteBtn.type = 'button';
                deleteBtn.textContent = '‚å´';
                deleteBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    deleteNumber();
                });
                numberPadEl.appendChild(deleteBtn);

                updateNumberPad();
            }

            function updateNumberPad() {
                const usedNumbers = new Set();
                
                for (let row = 0; row < size; row++) {
                    for (let col = 0; col < size; col++) {
                        if (playerBoard[row][col] !== 0) {
                            usedNumbers.add(playerBoard[row][col]);
                        }
                    }
                }

                document.querySelectorAll('.number-btn[data-num]').forEach(btn => {
                    const num = parseInt(btn.dataset.num);
                    if (usedNumbers.has(num)) {
                        btn.classList.add('used');
                    } else {
                        btn.classList.remove('used');
                    }
                });
            }

            function placeNumber(num) {
                if (!selectedCell) {
                    messageEl.textContent = 'Primero selecciona una celda.';
                    messageEl.className = 'message info';
                    return;
                }

                const [row, col] = selectedCell;
                
                // Verificar si es celda fija
                if (givenCells.some(([r, c]) => r === row && c === col)) {
                    messageEl.textContent = 'Esta celda no se puede modificar.';
                    messageEl.className = 'message error';
                    return;
                }

                // Verificar si el n√∫mero ya est√° usado
                for (let r = 0; r < size; r++) {
                    for (let c = 0; c < size; c++) {
                        if (playerBoard[r][c] === num && (r !== row || c !== col)) {
                            messageEl.textContent = `El ${num} ya est√° colocado.`;
                            messageEl.className = 'message error';
                            return;
                        }
                    }
                }

                // Colocar n√∫mero
                playerBoard[row][col] = num;
                
                const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
                cell.textContent = num;
                cell.classList.add('filled');
                cell.classList.remove('selected');
                
                selectedCell = null;
                messageEl.textContent = '';
                updateNumberPad();
            }

            function deleteNumber() {
                if (!selectedCell) {
                    messageEl.textContent = 'Primero selecciona una celda.';
                    messageEl.className = 'message info';
                    return;
                }

                const [row, col] = selectedCell;
                
                if (givenCells.some(([r, c]) => r === row && c === col)) {
                    messageEl.textContent = 'Esta celda no se puede modificar.';
                    messageEl.className = 'message error';
                    return;
                }

                playerBoard[row][col] = 0;
                
                const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
                cell.textContent = '';
                cell.classList.remove('filled');
                cell.classList.remove('selected');
                
                selectedCell = null;
                updateNumberPad();
            }

            // ===== VERIFICACI√ìN =====

            function checkSolution() {
                const total = size * size;
                
                // Verificar que todas las celdas est√©n llenas
                let emptyCount = 0;
                for (let row = 0; row < size; row++) {
                    for (let col = 0; col < size; col++) {
                        if (playerBoard[row][col] === 0) emptyCount++;
                    }
                }

                if (emptyCount > 0) {
                    messageEl.textContent = `Faltan ${emptyCount} celdas por rellenar.`;
                    messageEl.className = 'message error';
                    addVerification(`Comprobaci√≥n: faltan ${emptyCount} celdas`, 'error');
                    return;
                }

                // Verificar que cada n√∫mero del 1 al N existe exactamente una vez
                const numberCount = {};
                for (let row = 0; row < size; row++) {
                    for (let col = 0; col < size; col++) {
                        const num = playerBoard[row][col];
                        numberCount[num] = (numberCount[num] || 0) + 1;
                    }
                }

                for (let i = 1; i <= total; i++) {
                    if (!numberCount[i]) {
                        messageEl.textContent = `Falta el n√∫mero ${i}.`;
                        messageEl.className = 'message error';
                        addVerification(`Falta el n√∫mero ${i}`, 'error');
                        return;
                    }
                    if (numberCount[i] > 1) {
                        messageEl.textContent = `El n√∫mero ${i} est√° repetido.`;
                        messageEl.className = 'message error';
                        addVerification(`El n√∫mero ${i} est√° repetido`, 'error');
                        return;
                    }
                }

                // Verificar que cada n√∫mero es adyacente al siguiente
                let hasError = false;
                for (let num = 1; num < total; num++) {
                    const pos1 = findPlayerNumberPosition(num);
                    const pos2 = findPlayerNumberPosition(num + 1);
                    
                    if (!isAdjacent(pos1, pos2)) {
                        hasError = true;
                        
                        // Marcar celdas con error
                        const cell1 = document.querySelector(`.cell[data-row="${pos1[0]}"][data-col="${pos1[1]}"]`);
                        const cell2 = document.querySelector(`.cell[data-row="${pos2[0]}"][data-col="${pos2[1]}"]`);
                        cell1.classList.add('error');
                        cell2.classList.add('error');
                        
                        setTimeout(() => {
                            cell1.classList.remove('error');
                            cell2.classList.remove('error');
                        }, 2000);
                        
                        messageEl.textContent = `El ${num} y el ${num + 1} no son adyacentes.`;
                        messageEl.className = 'message error';
                        addVerification(`${num} y ${num + 1} no son adyacentes`, 'error');
                        return;
                    }
                }

                // ¬°Soluci√≥n correcta!
                messageEl.textContent = 'üéâ ¬°Felicidades! Has resuelto el Hidato.';
                messageEl.className = 'message success';
                addVerification('¬°Soluci√≥n correcta!', 'success');

                if (timerInterval) {
                    clearInterval(timerInterval);
                }

                showSolutionView(true);
            }

            function findPlayerNumberPosition(num) {
                for (let row = 0; row < size; row++) {
                    for (let col = 0; col < size; col++) {
                        if (playerBoard[row][col] === num) {
                            return [row, col];
                        }
                    }
                }
                return null;
            }

            function isAdjacent(pos1, pos2) {
                if (!pos1 || !pos2) return false;
                const rowDiff = Math.abs(pos1[0] - pos2[0]);
                const colDiff = Math.abs(pos1[1] - pos2[1]);
                return rowDiff <= 1 && colDiff <= 1 && (rowDiff + colDiff > 0);
            }

            // ===== UTILIDADES =====

            function clearAllCells() {
                let cellsToClear = 0;
                for (let row = 0; row < size; row++) {
                    for (let col = 0; col < size; col++) {
                        const isGiven = givenCells.some(([r, c]) => r === row && c === col);
                        if (!isGiven && playerBoard[row][col] !== 0) {
                            cellsToClear++;
                        }
                    }
                }

                if (cellsToClear === 0) {
                    messageEl.textContent = 'No hay celdas para borrar.';
                    messageEl.className = 'message info';
                    return;
                }

                showConfirmModal(
                    `¬øEst√°s seguro de que quieres borrar ${cellsToClear} celdas?`,
                    function() {
                        for (let row = 0; row < size; row++) {
                            for (let col = 0; col < size; col++) {
                                const isGiven = givenCells.some(([r, c]) => r === row && c === col);
                                if (!isGiven) {
                                    playerBoard[row][col] = 0;
                                    const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
                                    if (cell) {
                                        cell.textContent = '';
                                        cell.classList.remove('filled', 'selected');
                                    }
                                }
                            }
                        }
                        selectedCell = null;
                        updateNumberPad();
                        messageEl.textContent = `Se han borrado ${cellsToClear} celdas.`;
                        messageEl.className = 'message info';
                        addVerification(`${cellsToClear} celdas borradas`, 'info');
                    }
                );
            }

            function startTimer() {
                if (timerInterval) {
                    clearInterval(timerInterval);
                }
                startTime = new Date();
                timerInterval = setInterval(updateTimer, 1000);
                updateTimer();
            }

            function updateTimer() {
                const now = new Date();
                const elapsedTime = Math.floor((now - startTime) / 1000);
                const minutes = Math.floor(elapsedTime / 60).toString().padStart(2, '0');
                const seconds = (elapsedTime % 60).toString().padStart(2, '0');
                timerEl.textContent = `${minutes}:${seconds}`;
            }

            function addVerification(message, status) {
                const timeElapsed = timerEl.textContent;
                verificationHistory.push({
                    timestamp: new Date(),
                    timeElapsed: timeElapsed,
                    message: message,
                    status: status
                });

                const entryElement = document.createElement('p');
                entryElement.className = status;
                entryElement.textContent = `${verificationHistory.length}. ${timeElapsed} - ${message}`;
                verificationList.appendChild(entryElement);
            }

            function showSolutionView(isSuccess) {
                solutionTitle.textContent = 'IES Serran√≠a - Hidato';

                const currentDate = new Date().toLocaleDateString();
                const difficultyMap = {
                    'easy': 'F√°cil',
                    'medium': 'Medio',
                    'hard': 'Dif√≠cil'
                };

                solutionInfo.innerHTML = `
                    <p><strong>Estudiante:</strong> ${username}</p>
                    <p><strong>Fecha:</strong> ${currentDate}</p>
                    <p><strong>Tama√±o:</strong> ${size}√ó${size}</p>
                    <p><strong>Dificultad:</strong> ${difficultyMap[difficulty]}</p>
                    <p><strong>Tiempo total:</strong> ${timerEl.textContent}</p>
                `;

                // Grid de soluci√≥n
                solutionGrid.innerHTML = '';
                const cellSize = size <= 6 ? 45 : 38;
                solutionGrid.style.gridTemplateColumns = `repeat(${size}, ${cellSize}px)`;
                solutionGrid.style.gridTemplateRows = `repeat(${size}, ${cellSize}px)`;

                for (let row = 0; row < size; row++) {
                    for (let col = 0; col < size; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'solution-cell';
                        cell.style.width = cellSize + 'px';
                        cell.style.height = cellSize + 'px';
                        cell.textContent = playerBoard[row][col];

                        if (givenCells.some(([r, c]) => r === row && c === col)) {
                            cell.classList.add('given');
                        } else {
                            cell.classList.add('filled');
                        }

                        solutionGrid.appendChild(cell);
                    }
                }

                if (isSuccess) {
                    solutionMessage.textContent = 'üéâ ¬°Soluci√≥n correcta!';
                    solutionMessage.className = 'solution-message success';
                } else {
                    solutionMessage.textContent = 'Soluci√≥n incompleta';
                    solutionMessage.className = 'solution-message error';
                }

                // Historial
                solutionVerificationList.innerHTML = '';
                verificationHistory.forEach((entry, index) => {
                    const item = document.createElement('div');
                    item.className = `verification-item ${entry.status}`;
                    item.textContent = `${index + 1}. ${entry.timeElapsed} - ${entry.message}`;
                    solutionVerificationList.appendChild(item);
                });

                solutionView.style.display = 'block';
            }

            function captureAndDownloadPng() {
                const canvas = document.createElement('canvas');
                const width = 600;
                const height = 750;
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');

                // Fondo
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(0, 0, width, height);

                // T√≠tulo
                ctx.font = 'bold 24px Arial';
                ctx.fillStyle = '#2c3e50';
                ctx.textAlign = 'center';
                ctx.fillText('IES Serran√≠a - Hidato', width / 2, 40);

                // Info
                ctx.font = '14px Arial';
                ctx.textAlign = 'left';
                const currentDate = new Date().toLocaleDateString();
                const difficultyMap = { 'easy': 'F√°cil', 'medium': 'Medio', 'hard': 'Dif√≠cil' };

                let yPos = 70;
                ctx.fillText(`Estudiante: ${username}`, 50, yPos); yPos += 22;
                ctx.fillText(`Fecha: ${currentDate}`, 50, yPos); yPos += 22;
                ctx.fillText(`Tama√±o: ${size}√ó${size}`, 50, yPos); yPos += 22;
                ctx.fillText(`Dificultad: ${difficultyMap[difficulty]}`, 50, yPos); yPos += 22;
                ctx.fillText(`Tiempo: ${timerEl.textContent}`, 50, yPos); yPos += 30;

                // Mensaje
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'center';
                ctx.fillStyle = '#27ae60';
                ctx.fillText('üéâ ¬°Soluci√≥n correcta!', width / 2, yPos);
                yPos += 40;

                // Grid
                const gridSize = Math.min(width - 100, 350);
                const cellSize = gridSize / size;
                const startX = (width - gridSize) / 2;
                const startY = yPos;

                ctx.strokeStyle = '#2c3e50';
                ctx.lineWidth = 2;
                ctx.strokeRect(startX, startY, gridSize, gridSize);

                for (let row = 0; row < size; row++) {
                    for (let col = 0; col < size; col++) {
                        const x = startX + col * cellSize;
                        const y = startY + row * cellSize;
                        const isGiven = givenCells.some(([r, c]) => r === row && c === col);

                        // Fondo
                        ctx.fillStyle = isGiven ? '#3498db' : '#e8f8f5';
                        ctx.fillRect(x, y, cellSize, cellSize);

                        // Borde
                        ctx.strokeStyle = '#bdc3c7';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(x, y, cellSize, cellSize);

                        // N√∫mero
                        ctx.font = 'bold 16px Arial';
                        ctx.fillStyle = isGiven ? '#ffffff' : '#1abc9c';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(playerBoard[row][col].toString(), x + cellSize / 2, y + cellSize / 2);
                    }
                }

                // Historial
                yPos = startY + gridSize + 30;
                ctx.font = 'bold 14px Arial';
                ctx.fillStyle = '#2c3e50';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'alphabetic';
                ctx.fillText('Historial:', 50, yPos);
                yPos += 20;

                ctx.font = '12px Arial';
                for (let i = 0; i < Math.min(5, verificationHistory.length); i++) {
                    const entry = verificationHistory[i];
                    ctx.fillStyle = entry.status === 'success' ? '#27ae60' : (entry.status === 'error' ? '#e74c3c' : '#3498db');
                    ctx.fillText(`${i + 1}. ${entry.timeElapsed} - ${entry.message}`, 60, yPos);
                    yPos += 18;
                }

                // Descargar
                try {
                    const dataUrl = canvas.toDataURL('image/png');
                    downloadLink.href = dataUrl;
                    downloadLink.download = `Hidato_${username}_${size}x${size}_${difficulty}_${timerEl.textContent.replace(':', 'm')}s.png`;
                    downloadLink.click();
                    addVerification('Imagen PNG generada', 'success');
                } catch (e) {
                    console.error('Error al generar PNG:', e);
                    addVerification('Error al generar PNG', 'error');
                }
            }

            // Teclado f√≠sico
            document.addEventListener('keydown', function(e) {
                if (!selectedCell) return;

                const total = size * size;
                const key = e.key;

                if (key === 'Backspace' || key === 'Delete') {
                    deleteNumber();
                    e.preventDefault();
                } else if (key >= '0' && key <= '9') {
                    // Para n√∫meros de dos d√≠gitos, acumular
                    const num = parseInt(key);
                    if (num >= 1 && num <= total) {
                        placeNumber(num);
                    }
                }

                // Navegaci√≥n con flechas
                const [row, col] = selectedCell;
                let newRow = row, newCol = col;

                switch (e.key) {
                    case 'ArrowUp': newRow = Math.max(0, row - 1); e.preventDefault(); break;
                    case 'ArrowDown': newRow = Math.min(size - 1, row + 1); e.preventDefault(); break;
                    case 'ArrowLeft': newCol = Math.max(0, col - 1); e.preventDefault(); break;
                    case 'ArrowRight': newCol = Math.min(size - 1, col + 1); e.preventDefault(); break;
                }

                if (newRow !== row || newCol !== col) {
                    const isGiven = givenCells.some(([r, c]) => r === newRow && c === newCol);
                    if (!isGiven) {
                        selectCellHandler(newRow, newCol);
                    }
                }
            });

            // Responsive
            let resizeTimeout;
            window.addEventListener('resize', function() {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(function() {
                    renderBoard();
                }, 250);
            });
        });
    </script>
</body>
</html>
